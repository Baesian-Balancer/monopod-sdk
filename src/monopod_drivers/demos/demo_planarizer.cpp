/**
 * @file demo_1_motor_print_everything.cpp
 * @copyright Copyright (c) 2018-2020, New York University and Max Planck
 * Gesellschaft, License BSD-3-Clause
 */

#include <tuple>

#include <monopod_sdk/monopod_drivers/devices/can_bus.hpp>
#include <monopod_sdk/monopod_drivers/devices/boards.hpp>
#include "monopod_sdk/monopod_drivers/planarizer.hpp"
#include "monopod_sdk/common_header.hpp"

const int NUMBER_JOINTS = 3;

static THREAD_FUNCTION_RETURN_TYPE printing_loop(void* planarizer_ptr)
{
    // cast input arguments to the right format --------------------------------

    monopod_drivers::Planarizer& planarizer = *(static_cast<monopod_drivers::Planarizer*>(planarizer_ptr));

    while (true)
    {
        auto data = planarizer.get_measurements();
        std::cout << "Current Position for: "
         << "(boom_connector_joint: "   << data[monopod_drivers::boom_connector_joint][monopod_drivers::position] << ")"
         << "(planarizer_yaw_joint: "   << data[monopod_drivers::planarizer_yaw_joint][monopod_drivers::position] << ")"
         << "(planarizer_pitch_joint: " << data[monopod_drivers::planarizer_pitch_joint][monopod_drivers::position] << ")"
         << std::endl;

         std::cout << "Current Velocity for: "
          << "(boom_connector_joint: "   << data[monopod_drivers::boom_connector_joint][monopod_drivers::velocity] << ")"
          << "(planarizer_yaw_joint: "   << data[monopod_drivers::planarizer_yaw_joint][monopod_drivers::velocity] << ")"
          << "(planarizer_pitch_joint: " << data[monopod_drivers::planarizer_pitch_joint][monopod_drivers::velocity] << ")"
          << std::endl;

          /*
          * You get the indexes from the common header files. you can use the map to get them better.
          */

    }
    return THREAD_FUNCTION_RETURN_VALUE;
}

int main(int, char**)
{
    auto can_bus_ = std::make_shared<monopod_drivers::CanBus>("can0");
    auto board_ = std::make_shared<monopod_drivers::CanBusMotorBoard>(can_bus_);

    auto planarizer = std::make_shared<monopod_drivers::Planarizer>(board_, 2);

    // // start real-time leg loop --------------------------------------------
    real_time_tools::RealTimeThread printing_thread;
    printing_thread.create_realtime_thread(&printing_loop, &planarizer);


    rt_printf("control loop started \n");
    printing_thread.join();
    return 0;
}
